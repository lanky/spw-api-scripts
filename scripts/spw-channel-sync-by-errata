#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# RHN/Spacewalk XMLRPC API script
# ** delete as appropriate below **
# requires the python-rhnapi and python-progressbar modules
# also requires PyYAML if you want to use channel grouping
# for syncing/updating whole builds
#
# Copyright 2013 Stuart Sears <stuart.sears@man.com>
#
# This file is part of spw-api-scripts
#
# spw-api-scripts is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 2 of the License, or (at your option)
# any later version.
#
# spw-api-scripts is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with spw-api-scripts. If not, see http://www.gnu.org/licenses/.


# --------------------- Python Standard Library Modules ---------------------- #
import os
import sys
import re
from optparse import OptionParser, OptionGroup
from operator import itemgetter

# --------------------------- Non-Standard modules --------------------------- #
try:
    import yaml
    has_yaml = True
except ImportError:
    has_yaml = False
    pass



# -------------------------- Custom Python Modules --------------------------- #
import rhnapi
from rhnapi import channel, errata, packages

from progressbar import Counter,Percentage,ProgressBar,Timer,Bar
# ------------------------- Docstring and file info -------------------------- #
__doc__ = """
%s
Synchronises two channels via errata cloning/publishing and package pushing
""" % os.path.basename(__file__)
__author__ = "Stuart Sears <stuart.sears@man.com>"

# -------------------------- RHN API Configuration --------------------------- #

# server hostname and config file location
RHNCONFIG = '~/.rhninfo'
RHNHOST = 'localhost'

# authentication information
# put these in your configfile, dammit;
RHNUSER = None
RHNPASS = None

# channel group configuration, ordered list, last entry wins
CHANNELMAPS = [ "/etc/sysconfig/rhnapi/channels.yaml", "~/.rhnapi/channels.yaml" ]


# --------------------------- Script Configuration --------------------------- #
# put global variables for the script in here

rhpatt = re.compile('^RH[BES]A-\d{4}:\d{4}(?:-\d)?')
# we use this repeatedly, so define it globally
pkgfmt = "%(name)s-%(version)s-%(release)s.%(arch_label)s"

# ---------------------------------------------------------------------------- #

def parse_cmdline(argv):
    """
    process and check commandline options and arguments.
    Called against sys.argv[1:] to ignore the script name itself.
    """
    def error(errlines, usage=True, exitcode=1):
        """
        parser-specific error handling
        params:
        errlines(list)      - list (or tuple/set) of lines in error message
        exitcode(int)       - return code for exit statement.
        """
        print "\n".join(errlines)
        parser.print_help()
        sys.exit(exitcode)

    preamble = """Update one channel from another, using errata where possible"""

    usagestr = "%prog [RHNOPTS] [--test|--report] [-s SOURCE|-g GROUP] DESTCHANNEL..."
    
    # initialise our parser and set some default options
    parser = OptionParser(usage = usagestr, description = preamble)
    parser.add_option("--debug", action = "store_true", default = False,
        help = "enable debug output for RHN session (XMLRPC errors etc.) Sets loglevel to DEBUG.")
    parser.add_option('-v', '--verbose', action = 'store_true', default = False,
        help = "increase verbosity. Sets loglevel to INFO")

    # RHN Satellite options group
    rhngrp = OptionGroup(parser, "RHN Satellite Options", "Defaults can be set in your RHN API config file (%s)" % RHNCONFIG )
    rhngrp.add_option("--server",help="RHN satellite server hostname [%default]", default=RHNHOST)
    rhngrp.add_option("--login", help="RHN login (username)" , default=RHNUSER)
    rhngrp.add_option("--pass", dest = "password", help="RHN password. This is better off in a config file.", default=RHNPASS)
    rhngrp.add_option("--config", dest = "config", help="Local RHN configuration file [ %default ]", default=RHNCONFIG)
    rhngrp.add_option("--cache", action = "store_true", default = False,
        help = "save usernames and password in config file, if missing")
    rhngrp.add_option("--log", dest = "logfile", default = None,
        help = "log output to the given filename. If you enable logging without this, logs go to stderr")
    parser.add_option_group(rhngrp)

    changrp = OptionGroup(parser, "Channel Selection options")
    changrp.add_option("-s", "--source",
        help="Source Channel for package and errata updates (calculated if missing)")
    changrp.add_option("--report", action="store_true", default=False,
        help="Generate a report without making changes")
    changrp.add_option("--test", action="store_true", default=False,
        help="Run comparisons and show a brief summary, but make no changes")
    changrp.add_option("-o", "--output", help="output file for saving a generated report. Without this it is printed to stdout")
    parser.add_option_group(changrp)
    
    if has_yaml:
        buildgrp = OptionGroup(parser, "Channel Group / Build options")
        buildgrp.add_option("-g", "--group","--build", dest="group", 
            help="Channel group (build) defined in configuration file. Overrides -s, args are ignored")
        buildgrp.add_option("--group-file", action="append", default=CHANNELMAPS, 
            help="location of group configuration file in YAML format[%default]")
        buildgrp.add_option("--list-groups", action="store_true", default=False,
            help="List defined groups and exit")
        parser.add_option_group(buildgrp)

    # by default
    if len(argv) == 0:
        error(["No options or arguments provided"], True, 0)

    opts, args = parser.parse_args(argv)
    # check the args for errors etc...

    if opts.debug:
        opts.loglevel = 10
    elif opts.verbose:
        opts.loglevel = 20
    else:
        opts.loglevel = 30
    # finally...

    if opts.report and not opts.Test:
        opts.test = True

    if not has_yaml:
        opts.group = None
        opts.group_file = None
        opts.list_groups = False

    # we have a group specified
    if opts.group:
        if opts.source:
            error(["ERROR: --group and --source are mutually exclusive",
                   "Please select one or the other"], True, 1)
        elif len(args) > 0:
            print "WARNING: command line arguments are ignored with --group"
            args = []
    # we don't have a 'group' but we do have a 'source'
    elif opts.source:
        # we've provided a source but no destination. Oops.
        if len(args) == 0:
            error(["ERROR: No destination channels to sync from source channel %s" % opts.source], True, 1)
    # finally, we have no 'group' or 'source', but we do have destination channels.
    else:
        if len(args) > 0:
            print "No source channel provided, will work it out based on channel cloning"

    return opts, args

# ---------------------------------------------------------------------------- #

def gen_report(channelmaps):
    """
    Abstraction of the report printing parts

    iterates over chandata and produces a formatted report of errata and 
    non-errata packages to sync, per destination channel

    parameters:
        channelmaps (list of dict) - channel info, including errata and package lists

    returns:
        list of lines to output as required
    """
    outlines = []

    for chandata in channelmaps:
        # because I use this repeatedly, avoid repeated dict lookups
        errdict = chandata['errindex']
        pkgdict = chandata['pkgindex']
        # this is being removed
        errheader = "Errata to sync from %%(source)s: %d" % len(errdict.keys())
        pkgheader = "Non-errata packages to sync from %%(source)s: %d" % len(pkgdict.keys())

        outlines.append("Channel: %(label)s" % chandata)
        outlines.append("%s" % ("-".ljust(len(chandata.get('label')) + 9, '-')))
        outlines.append(errheader % chandata)
        # do errata reporting if there are any to sync
        if len(errdict.keys()) > 0:
            errlen = max(len(k) for k in errdict.keys()) 
            errfmt =  "%%(advisory)-%ds %%(synopsis)s" % errlen
#            outlines.append( errfmt % { 'advisory' : "Erratum", 'synopsis' : "Synopsis" })
#            outlines.append( errfmt % { 'advisory' : "=".ljust(errlen,"="), 'synopsis' :"========"})
            for err in sorted(errdict.values(), key=itemgetter('advisory')):
                outlines.append((errfmt % err).strip())

        outlines.append("")
        outlines.append(pkgheader % chandata)
        if len(pkgdict.keys()) > 0:
            pkglen = max(len(k) for k in pkgdict.keys())
            pkgfmt =  "%%(nvrea)-%ds %%(summary)s" % pkglen
#            outlines.append( pkgfmt % {'nvrea' : "Package", 'summary' : "Summary"} )
#            outlines.append( pkgfmt % { 'nvrea' : "=".ljust(pkglen,"="), 'summary' : "======="})
            for pkg in sorted(pkgdict.values(), key=itemgetter('nvrea')):
                outlines.append((pkgfmt % pkg).strip())

        outlines.append("")

    return outlines
# ---------------------------------------------------------------------------- #

def load_groupfiles(groupfilelist, logger=None):
    """
    Walks through a list of YAML-format channel group files and return a nested dict
    containing the appropriate information.

    Later files in the list can override earlier ones
    """
    merged_data = {}
    for filename in groupfilelist:
        try:
            if logger:
                logger.debug("processing %s" % filename)
            fd = open(os.path.expanduser(filename), 'r')
            data = yaml.load(fd.read())
            fd.close()
            # here we override existing values with those from
            # newer files
            merged_data.update(data)
        except  IOError, I:
            if logger:
                logger.error("unable to open/read %s, skipping it" % filename)
            else:
                print "unable to open/read %s, skipping it" % filename
            continue

    if len(merged_data.keys()) == 0:
        print "No channel groupings found"
        return None
    else:
        return merged_data


# ---------------------------------------------------------------------------- #

def get_group(groupname,groupdata):
    """
    extract the chosen channel group from the YAML-format mapping file
    in this format:
    group_name: 
        source:
        label:
        children:
          - label:
            label:
          - ...

    return a one-to-one mappeing (list of dict) like this:
    [ { label : source }, { label : source }, ... ]
    with the base channel first.
    """
    groupinfo = groupdata.get(groupname)
    if groupinfo:
        group_pairs = [{ 'label'  : groupinfo.get('label'),
                          'source' : groupinfo.get('source') }]

        for child in groupinfo.get('children'):
            group_pairs.append(child)

        return group_pairs
    else:
        print "Cannot find a definition for group %s" % groupname
        return None

# ---------------------------------------------------------------------------- #

def list_groups(groupdata, padding=30):
    """
    pretty-prints the groups from our merged configuration
    """
    fmt = "%%(label)-%ds %%(source)s" % padding
    for grp, props in groupdata.iteritems():
        print "Group: %s - %s" %  (grp, props.get('description', ''))
        print fmt % {'label' : "Channel Label", 'source' : "Cloned From"}
        print fmt % {'label' : "=============", 'source' : "==========="}
        print fmt % props, " (base)"
        for child in props.get('children'):
            print fmt % child
        print "--"

# ---------------------------------------------------------------------------- #

def main(argv):    
    """
    This is overcomplicated and should be broken down, really
    """
    opts, args = parse_cmdline(argv[1:])
    destchannels = args


    try:
        RHN = rhnapi.rhnSession(opts.server,
                                opts.login,
                                opts.password,
                                config=opts.config,
                                savecreds=opts.cache,
                                debug=opts.debug,
                                logfile=opts.logfile,
                                logenable=True,
                                logname=os.path.basename(argv[0]),
                                loglevel=opts.loglevel,
                                )

        # this doesn't require RHN at all...
        if opts.list_groups:
            groupdata = load_groupfiles(opts.group_file, RHN.logger)
            list_groups(groupdata)
            sys.exit(0)


        multisource = True
        # groups override --source and destination channels
        if opts.group:
            multisource = True
            # returns list of dict: { 'label' : channel_label, 'source' : channel_source }
            RHN.logDebug("fetching group info for group %s" % opts.group)
            groupdata = load_groupfiles(opts.group_file, RHN.logger)
            channelmaps = get_group(opts.group, groupdata)
            # not sure what I wanted this one for!
            if channelmaps is None:
                print "Unable to parse information for group %s" % opts.group
                sys.exit(2)
            # sourcechannels = [ c.get('source') for c in channelmaps ]
        # perhaps we should combine the next two parts?
        # there is some duplication of code
        elif opts.source:
            multisource = False
            channelmaps = []
            # parse any and all destination channels provided
            chanlist = [ ch.get('label') for ch in channel.listSoftwareChannels(RHN) ]
            print destchannels
            for chan in destchannels:
                RHN.logDebug("Checking channel %s" % chan)
                if chan not in chanlist:
                    RHN.logError("Channel %s does not appear to exist" % chan)
                    # continue
                else:
                    channelmaps.append({ 'label' : chan, 'source' : opts.source })

            # because the source is the same for all channels, let's do this once and once only
            srcpkgs = channel.listLatestPackages(RHN, opts.source)
            srcidx = dict(zip([ pkgfmt % p for p in srcpkgs ], srcpkgs))
        else:
            multisource = True
            channelmaps = []
            for chan in args:
                RHN.logDebug("Looking up clone source for channel %s" % chan)
                chandetails = channel.getDetails(RHN, chan)
                if chandetails:
                    chansource = chandetails.get('clone_original')
                    if len(chansource.strip()) == 0:
                        RHN.logError("%(label)s is not a cloned channel and no source channel was provided. Skipping" % chandetails)
                        continue
                    else:
                        channelmaps.append({ 'label' : chan , 'source' : chansource })

    # okay, now we have a 'channelmaps' dict, we can work our way through it.
        if opts.group:
            print "Processing channel group %s" % opts.group
        for chanmap in channelmaps:
            RHN.logInfo("processing %(source)s => %(label)s" % chanmap)
            print "* %(label)s" % chanmap
            dstchan = chanmap.get('label')
            srcchan = chanmap.get('source')
            # does everything map to the same source
            if multisource:
                RHN.logInfo("Indexing latest packages in source channel %s" % srcchan)
                srcpkgs = channel.listLatestPackages(RHN,  srcchan)
                srcindex = dict(zip([ pkgfmt % p for p in srcpkgs ], srcpkgs))

                RHN.logInfo("Indexing errata in source channel %s" % srcchan)
                srcerrata = channel.listErrata(RHN, srcchan)
                srcerridx = dict(zip((e.get('advisory') for e in srcerrata),srcerrata))

            # else we already have srcpkgs and srcidx
            
            # get a list of packages already in the destination channel
            RHN.logInfo("Indexing latest packages in destination channel %s" % dstchan)
            dstpkgs = channel.listLatestPackages(RHN, dstchan)
            dstindex = dict(zip([ pkgfmt % p for p in dstpkgs ], dstpkgs))

            # get a list of packages not in the destination channel
            pkgdiff = set(srcindex.keys())
            pkgdiff.difference_update(set(dstindex.keys()))

            # log the number of packages we need to inspect
            RHN.logDebug("%d packages in %s but not in %s" %(len(pkgdiff), srcchan, dstchan))

            # okay, now we have a set of package NVREA strings to find errata for.
            # when we find these errata, we'll check if they provide other packages in our list
            # a dict containing non-errata packages to sync, indexed on NVRA
            chanmap['pkgindex'] = {}
            chanmap['pkglist'] = set([])

            # a dict containing sync errata, indexed on advisory
            chanmap['errindex'] = {}
            chanmap['errlist'] = set([])

            if len(pkgdiff) > 0:
                # sets for advisory and package names
                count = 0
                widgets = ['progress: ', Counter(), '/ %d Packages [' % len(pkgdiff), 
                           Percentage(), ']', Bar(), '(', Timer(), ')']
                pbar = ProgressBar(widgets=widgets, maxval=len(pkgdiff), term_width=80).start()
                # process all packages and find the errata providing them, if there are any
                for idx, pkg in enumerate(pkgdiff):
                    pkgobj = srcindex.get(pkg)
                    RHN.logDebug("Getting details for package %s" % pkg)
                    pkgdetails = packages.getDetails(RHN, pkgobj.get('id'))
                    pkgobj.update(pkgdetails)
                    pkgobj['nvrea'] = pkg
                    RHN.logDebug("Finding Errata for package %s" % pkg)
                    erratalist = packages.listProvidingErrata(RHN, pkgobj.get('id'))
                    if len(erratalist) == 0:
                        RHN.logDebug("Package %s does not appear to come from an erratum" % pkg)
                        chanmap['pkglist'].add(pkg)
                        chanmap['pkgindex'][pkg] = pkgobj
                    else:
                        for e in erratalist:
                            adv = e.get('advisory')
                            if adv in srcerridx.keys():
                                RHN.logDebug("Adding %s to sync list" % adv)
                                errdetails = errata.getDetails(RHN, adv)
                                e.update(errdetails)
                                chanmap['errlist'].add(adv)
                                chanmap['errindex'][adv] = e
                            else:
                                RHN.logDebug("Cannot find Erratum %(advisory)s in source channel, ignoring" % e)
                    pbar.update(idx + 1)
                print

                RHN.logInfo("Found %d Errata to Sync from %s to %s" % (len(chanmap['errlist']),srcchan,dstchan))
                RHN.logInfo("Found %d packages not provided by errata" % len(chanmap['pkglist']))
            print "  Errata: %d, Packages: %d" % (len(chanmap['errlist']), len(chanmap['pkglist']))



# ----------- At this point we've worked through all our channels ------------ #
        if opts.test:
            print "Running in test mode, no changes will be made"
            if opts.report:
                reportlines = gen_report(channelmaps)
                if opts.output:
                    try:
                        RHN.logInfo("outputting report to %s" % opts.output)
                        fd = open(opts.output, 'wb')
                        if opts.group:
                            fd.write("Channel Group: %s\n" % opts.group)
                        fd.write('\n'.join(reportlines))
                        sys.exit(0)
                    except OSError, E:
                        RHN.logError("Unable to create/write to output file %s" % opts.output)
                        RHN.logError("Error was: %s" % E.strerror)
                        print "Failed to create %s - %s" %(opts.output, E.strerror)
                        sys.exit(255)
                    except IOError, E:
                        RHN.logError("Unable to create/write to output file %s" % opts.output)
                        RHN.logError("Error was: %s" % E.strerror)
                        print "Failed to create %s - %s" %(opts.output, E.strerror)
                        sys.exit(255)
                        
                    finally:
                        print "writing output to %s" % opts.output
                        fd.close()
                # test/report mode without output file, print report instead
                else:
                    print '\n'.join(reportlines)
                    sys.exit(0)


## old code follows
# ---------- WE'LL NEED TO WALK OVER THE LIST OF CHANNEL MAPS HERE ----------- #
        else:
            print "Beginning sync process"
            for chanmap in channelmaps:
                # we are not in test mode, try syncing stuff
                erratalist = chanmap.get('errlist', [])
                packagelist = chanmap.get('pkglist', [])
                destchannel = chanmap.get('label')
                if len(erratalist) > 0:
                    # we have errata for syncing
                    cloneme = set(x for x in erratalist if rhpatt.match(x))
                    publishme = erratalist.difference(cloneme)

                    # This is unlikely as we'll normally just do this for
                    # custom channels, but nonetheless...
                    if len(cloneme) > 0:
                        res = errata.cloneAsOriginal(RHN, destchannel, list(cloneme))
                        if res:
                            RHN.logInfo("Cloned %d errata into %s" %(len(cloneme), destchannel))
                    if len(publishme) > 0:
                        # we have to publish errata one-by-one
                        # we'll show a progressbar for this
                        widgets = ['Publishing Errata: ', 
                                    Counter(), 
                                    '/ %d [' % len(publishme), 
                                    Percentage(), ']', 
                                    Bar(), 
                                    '(', Timer(), ')']
                        pbar = ProgressBar(widgets=widgets, 
                                           maxval=len(publishme), 
                                           term_width=80).start()

                        for ind, pberr in enumerate(publishme):
                            RHN.logDebug("publishing %s" % pberr)
                            res = errata.publishAsOriginal(RHN, pberr, [ destchannel ])
                            if res:
                                RHN.logInfo("Published %s" % pberr)
                            else:
                                RHN.logWarn("Failed to publish %s" % pberr)
                            pbar.update(ind +1)
                        print

                if len(packagelist) > 0:
                    print "adding %d non-errata packages to %s" %(len(packagelist), destchannel)
                    RHN.logInfo("Adding non-errata packages")
                    pkgids = [ p.get('id') for p in chanmap['pkgindex'].values() ]
                    if channel.addPackages(RHN, destchannel, pkgids):
                        RHN.logInfo("Succesfully added %d packages to channel %s" %(len(pkgids), destchannel))
                    else:
                        RHN.logError("Failed to add pacakges to channel %s. See logs for details" % destchannel)
                else:
                    print "No packages to sync to %(label)s" % chanmap
                

    except KeyboardInterrupt:
        print "Operation cancelled by keystroke."
        sys.exit(1)
    
if __name__ == '__main__':
    main(sys.argv)



# footer - do not edit below here
# vim: set et cindent ts=4 sts=4 sw=4 ft=python nofen:
